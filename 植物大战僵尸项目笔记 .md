# 植物大战僵尸项目笔记

<img src="C:\Users\Ve\AppData\Roaming\Typora\typora-user-images\image-20230627175536715.png" alt="image-20230627175536715" style="zoom:50%;" />

项目属性内字符集一定要设置为多字节字符集！！！

## 游戏初始化

游戏内采用了随机函数rand，故要初始化随机种子srand(time(null))。

```c++
#include<graphics.h> 图形库
loadimage(&imgMenu, "res/menu.png");
```

1. 利用图形库内置函数加载所有的资源图片（背景图，植物，阳光，僵尸，子弹等资源）。
2. 初始化游戏终止条件和游戏状态，对子弹池，阳光池等内存单位初始化。
3. 创建好固定大小的游戏窗口。
4. 为了游戏内部字体美观，替换游戏内部字体。 
5. 用枚举变量设置植物类型，阳光球状态，游戏状态

```C++
enum {WAN_DAO,XIANG_RI_KUI,SHI_REN_HUA,ZHI_WU_COUNT};	//植物枚举
enum {SUNSHINE_DOWN,SUNSHINE_GROUND,SUNSHINE_COLLECT,SUNSHINE_PRODUCT};  //阳光球状态枚举
enum { GOING, WIN, FAIL };
```



## 游戏开始界面

1. 此模块实现了游戏开始界面功能，用户可以选择进入游戏或者进入游戏设置页面。
2. 初始化并渲染游戏初始页面背景图。

```c++
putimage(x, y, &imgMenu); 渲染图片到x，y指定的坐标上
```

<img src="C:\Users\Ve\AppData\Roaming\Typora\typora-user-images\image-20230627151507806.png" alt="image-20230627151507806" style="zoom:50%;" />

​																							x,y坐标示意图

3. 调用ExMessage 获取鼠标位置和用户是否点击鼠标左键，判断用户采取进入游戏或者进入设置页面。
4. **渲染图片时采用双缓冲设置，先将要绘制的内容一次性绘制在图片上，再把图片输出，避免不断从内存读取数据而导致的屏幕闪烁。**

## 正式进入之前的开场动画

1. 因为游戏战地背景图长是1400像素，游戏窗口是900像素长，所以开场动画利用for循环更改x坐标来实现游戏开场滚**动画面。** 

```C++
int xMin = 900 - 1400
    for (int x = 0; x >= xMin; x -= 4) {	//每帧移动4像素
        BeginBatchDraw();

        putimage(x, 0, &imgBg); // 渲染滚动效果的游戏背景图

        count++;
        // 渲染场上的9个僵尸
        for (int k = 0; k < 9; k++) {
            putimagePNG(points[k].x - xMin + x, points[k].y, &imgZmStand[index[k]]);
            if (count >= 10) {// 限制站立僵尸的帧动画速度
                index[k] = (index[k] + 1) % 11;
            }
        }
        if (count >= 10)count = 0;

        EndBatchDraw();
        Sleep(5);
    }
```

2. 在开场右侧有本轮关卡的处于僵尸站立状态（提前设计好僵尸的站位坐标，也可以采用rand函数随机设置但是不如手动设计的位置好看），等待进攻。随着背景图渲染，僵尸的图像也逐渐出现在游戏窗口内
3. 处于滚动状态的背景图，僵尸的x坐标也在一直改变，其计算公式为：僵尸目前坐标-xMin+x（补偿僵尸的横坐标）
4. 向右滚动画面结束后，采用类似方法向左滚动画面（经过测算，向左移动112像素长度即可）

## 状态栏下滑动画

实现方法与开场滚动画面类似，此处略。

## 渲染游戏战斗过程中的图片

1. **渲染图片的顺序不同就可以实现图层的功能**， 后渲染的图像可以叠加显示在先前的图片之上，故先渲染游戏战斗背景图，植物选择状态栏，选择状态栏内植物卡片，草地上已经种植好的植物，鼠标拖动过程中的植物等。
2. 遍历地图上所有位置，若检测到此处有植物，根据帧序号和坐标位置进行渲染图片。改变帧序号即可实现动态显示。
3. 检测鼠标是否选中植物（即当前选择的植物信息），根据鼠标的实时坐标信息渲染静态的植物。
4. 遍历僵尸池，子弹池，阳光池内部所有资源，若检测到有被使用的资源，根据其不同状态进行渲染（子弹击中僵尸效果or子弹飞行效果 或者僵尸行走or僵尸攻击状态）

## 检测鼠标点击

1. 采用ExMessage和peekmessage判断用户鼠标是否有新的操作。
2. 若是检测到用户点击了鼠标左键，若阳光值足够，根据鼠标当前位置计算判断选择种植的植物，更改选择的植物数据，在渲染模块进行渲染。若鼠标位置处于阳光球位置则设置该阳光球处于回收阳光球状态，设置该阳光球起点与终点坐标和速度信息，播放搜集阳光音乐。
3. 若是检测到用户点击了鼠标右键，若当前地图位置合法则计算出该植物的行和列等坐标信息。种植下植物后清空当前选择的植物信息。

## 更新游戏数据

### 更新草地上植物，僵尸的帧动画序号

程序每次运行到此函数，就遍历草地上，僵尸池，阳光池内部被使用的单位，然后在允许的范围内更改帧动画序号，从而实现动画效果。

### 创建僵尸

从僵尸池内部寻找一个空资源单位，将此单位状态设置为占用，初始化该僵尸的坐标信息，速度，血量，状态信息等

### 更新僵尸数据

若僵尸存活时，若处于行走状态只需要更改其x坐标和帧动画序号；若处于攻击植物状态时停止移动，更改帧动画序号。若僵尸死亡，更改死亡帧动画序号，当死亡动画播放一遍后，清空该僵尸在僵尸池内部的所有数据。若此时的杀敌数达到获胜条件则设置当前游戏状态信息gameStatus。

### 创建阳光

首先从阳光球池内部取出一个可用的单位。最初采用三角函数tan方式实现阳光球回收动画，但是效果僵硬不美观，后续采用**贝塞尔曲线改进**。

1. 地图上方自然掉落的阳光球：初始化随机起点和终点坐标，每次移动的像素。（直线运动，贝塞尔曲线只需要起点终点两个点数据即可）
2. 向日葵生产的阳光球：遍历地图所有植物，若向日葵的阳光计时器到达指定时间，则开始生产一个阳光球。

初始化贝塞尔曲线的起点终点，和p2,p3这两个控制曲线形状的点，速度信息。

### 更新阳光球数据

遍历阳光球池内部所有单位，阳光球有如下状态：

1. 自然下降的阳光球：更新当前的y坐标，实现匀速下降效果，坐标计算公式：p1 + t*(p4-p1)
2. 掉落地上的阳光球：增加阳光球存活时间，超时且用户并未搜集则清楚该阳光球的所有数据。
3. 向日葵生产中的阳光球：采用贝塞尔曲线计算公式，根据设置好的4个点坐标，更改阳光球的x，y坐标
4. 回收过程中的阳光球：与自然下降的阳光球运动轨迹相同，采用匀速直线运动。当该阳光球到达终点后更新系统的总阳光值。

### 创建子弹

首先遍历僵尸池出现在了第几行，且该行存在豌豆时利用植物结构体内部定义的射击定时器控制射击间隔时间，再从子弹池内部取出可用的资源，初始化子弹的行列信息，速度，子弹状态信息。

### 更新子弹数据

更新所有飞行中的子弹x坐标，爆炸中的子弹动画播放一遍后清空该子弹所有数据信息

## 子弹命中僵尸

由于僵尸横坐标x实时更新，故子弹命中僵尸的范围是zms.x+80。若子弹和僵尸位于同一行且子弹的横坐标进入了命中范围区域，扣除僵尸血量且把子弹设为静止，由飞行状态改为爆炸状态。若僵尸在本轮攻击下，血量=0，则把僵尸速度置零且设为死亡状态。

## 僵尸攻击植物

1. 更新僵尸的攻击距离（80个像素长度），遍历所有僵尸，获取僵尸的行数据，检测在整个地图在该行有哪些植物进入了僵尸的攻击范围。
2. 设置植物进入受伤状态，计算死亡倒计时，僵尸状态换为攻击状态，速度为0，重置帧序号为0。若植物被僵尸吃掉，清空地图上该位置的植物所有信息，僵尸更换为行走状态，恢复速度。

## 结算游戏

根据gameStatus值，渲染不同的图片播放对应的音乐，跳出主函数循环，结束游戏。

